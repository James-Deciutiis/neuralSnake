import { update as updateSnake, draw as drawSnake, SNAKE_SPEED, AUTOMATIC_MODE, getSnakeHead, snakeIntersection, onSnake} from './snake.js'
import { update as updateFood, draw as drawFood, getRandomFoodPosition, getFoodPosition } from './food.js'
import { outsideGrid, randomGridPosition, GRID_SIZE } from './grid.js'
import { setInputDirection, getInputDirection } from './input.js'
import { NeuralNetwork } from './snakeNeuralNetwork.js'

let lastRenderTime = 0
let gameOver = false

const DIRECTION_NORTH = 1
const DIRECTION_NORTH_EAST = 2
const DIRECTION_EAST = 3
const DIRECTION_SOUTH_EAST = 4
const DIRECTION_SOUTH = 5
const DIRECTION_SOUTH_WEST = 6
const DIRECTION_WEST = 7
const DIRECTION_NORTH_WEST = 8
const THRESHOLD = 0.25

const nn = new NeuralNetwork(4, 30, 4)
const gameBoard = document.getElementById('game-board')

function main(currentTime){
	window.requestAnimationFrame(main)
	const secondsSinceLastRender = (currentTime - lastRenderTime) / 1000
	if (secondsSinceLastRender < 1 / SNAKE_SPEED) return

	if(gameOver){
		if(confirm('You lose, press okay to restart')){
			window.location = '/'
		}
		return 
	}

	lastRenderTime = currentTime

	update()
	draw()
}
	
if(AUTOMATIC_MODE){
	let foodPosition = randomGridPosition()		
	let snakeHead = randomGridPosition()
	let fx, fy, hx, hy
	let direction 
	let north, east, south, west
	for (let i = 0; i < 1000000; i++){
		foodPosition = randomGridPosition()
		snakeHead = randomGridPosition()
		fx = foodPosition.x
		fy = foodPosition.y
		hx = snakeHead.x
		hy = snakeHead.y
		
		direction = findFoodDirection(fx, fy, hx, hy)
		north = direction == DIRECTION_NORTH || direction ==  DIRECTION_NORTH_EAST || direction == DIRECTION_NORTH_WEST ? 1 : 0
		east = direction == DIRECTION_EAST || direction == DIRECTION_NORTH_EAST || direction == DIRECTION_SOUTH_EAST ? 1 : 0
		south = direction == DIRECTION_SOUTH || direction == DIRECTION_SOUTH_EAST || direction == DIRECTION_SOUTH_WEST ? 1 : 0
		west = direction  == DIRECTION_WEST || direction == DIRECTION_SOUTH_WEST || direction == DIRECTION_NORTH_WEST ? 1 : 0
		nn.train(normalizeInput(fx, fy, hx, hy), [north, east, south, west])
	}

}

window.requestAnimationFrame(main)

function update(){
	updateFood()
	updateSnake()
	checkLoss()
	
	if(AUTOMATIC_MODE){
		let fx = getFoodPosition().x	
		let fy = getFoodPosition().y
		let hx = getSnakeHead().x	
		let hy = getSnakeHead().y	
	
		let prediction = nn.feedForward(normalizeInput(fx, fy, hx, hy)).data
		
		let max = 0.0
		let choice = 0
		for(let i = 0; i <= 3; i++){
			console.log(prediction[0][i])
			if(max < prediction[0][i]){
				max = prediction[0][i]
				choice = i
			}
		}
		
		if(choice == 0 && getInputDirection().y == 0){
			prediction = { x: 0 , y: -1 }
		}
		else if(choice == 1 && getInputDirection().x == 0){
			prediction = { x: 1, y: 0 }
		}
		else if(choice == 2 && getInputDirection().y == 0){
			prediction = { x: 0, y: 1 }
		}
		else if(choice == 3 && getInputDirection().x == 0){
			prediction = { x: -1, y: 0 } 
		}
		else{
			prediction = getInputDirection()
		}
		console.log("prediction: " + prediction.x + prediction.y)

		setInputDirection(prediction)
	}
}

function draw(){
	gameBoard.innerHTML = ''
	drawFood(gameBoard)
	drawSnake(gameBoard)
}

function findFoodDirection(fx, fy, hx, hy){
	//North check 1
	if (hx == fx){
		for(let i = hy; i >= 1; i--){
			if(i == fy){
				return DIRECTION_NORTH	
			}
		}
	}
	
	//North-east check 2
	for(let i = hx, j = hy; i < GRID_SIZE, j >= 1; i++, j--){
		if(i == fx && j == fy){
			return DIRECTION_NORTH_EAST
		}
	}

	//East check 3
	if (hy == fy){
		for(let i = hx; i < GRID_SIZE; i++){
			if(i == fx){
				return DIRECTION_EAST	
			}
		}
	}
	
	//South-east check 4
	for(let i = hx, j = hy; i < GRID_SIZE, j < GRID_SIZE; i++, j++){
		if(i == fx && j == fy){
			return DIRECTION_SOUTH_EAST
		}
	}
	
	//South check 5
	if (hx == fx){
		for(let i = hy; i < GRID_SIZE; i++){
			if(i == fy){
				return DIRECTION_SOUTH
			}
		}
	}
	
	//South-west check 6
	for(let i = hx, j = hy; i >= 1, j < GRID_SIZE; i--, j++){
		if(i == fx && j == fy){
			return DIRECTION_SOUTH_WEST
		}
	}
	
	//West 7
	if (hy == fy){
		for(let i = hx; i >= 1; i--){
			if(i == fx){
				return DIRECTION_WEST	
			}
		}
	}
	
	//North-west check 8
	for(let i = hx, j = hy; i >= 1, j >= 1; i++, j--){
		if(i == fx && j == fy){
			return DIRECTION_NORTH_WEST
		}
		else if(onSnake({x: i , i: j}){
			return 
		}
	}	
	
	return 0 
}

function normalizeInput(fx, fy, hx, hy){
	let retval = []
	retval[0] = (fx - 1) / (GRID_SIZE - 1)
	retval[1] = (hy - 1) / (GRID_SIZE - 1)
	retval[2] = (hx - 1) / (GRID_SIZE - 1)
	retval[3] = (hy - 1) / (GRID_SIZE - 1)

	return retval
}

function normalizeOutput(direction){
	return [(direction - 0)/(8 - 0)]
}

function checkLoss(){
	gameOver = (outsideGrid(getSnakeHead()) || snakeIntersection())
}
